// Copyright (c) 2015 Mute Communications Ltd.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// mutegenerate can be used by go:generate to generate code that includes the
// current git HEAD commit hash and date as constants.
package main

import (
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"

	"github.com/mutecomm/mute/def/version"
	"github.com/mutecomm/mute/util/git"
)

func printCode(w io.Writer, release bool, commit, date string) {
	if release {
		fmt.Fprintf(w, "{\n")
		fmt.Fprintf(w, "  \"release.Version\": %q,\n", version.Number)
		fmt.Fprintf(w, "  \"release.Commit\": %q,\n", commit)
		fmt.Fprintf(w, "  \"release.Date\": %q\n", date)
		fmt.Fprintf(w, "}\n")
	} else {
		fmt.Fprintf(w, "package release\n")
		fmt.Fprintf(w, "\n")
		fmt.Fprintf(w, "// This code has been generated by mutegenerate.\n")
		fmt.Fprintf(w, "// DO NOT EDIT AND DO NOT COMMIT TO REPOSITORY!\n")
		fmt.Fprintf(w, "\n")
		fmt.Fprintf(w, "const (\n")
		fmt.Fprintf(w, "\t// Commit is the git commit hash.\n")
		fmt.Fprintf(w, "\tCommit = %q\n", commit)
		fmt.Fprintf(w, "\t// Date is the git commit date.\n")
		fmt.Fprintf(w, "\tDate = %q\n", date)
		fmt.Fprintf(w, ")\n")
	}
}

func commitChanged(output, commit string) bool {
	// ignore all errors
	fc, err := ioutil.ReadFile(output)
	if err != nil {
		return true
	}
	lines := strings.Split(string(fc), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Commit = \"") {
			line = strings.TrimPrefix(line, "Commit = \"")
			line = strings.TrimSuffix(line, "\"")
			if line == commit {
				return false
			}
			return true
		}
	}
	return true
}

func fatal(err error) {
	fmt.Fprintf(os.Stderr, "%s: error: %s\n", os.Args[0], err)
	os.Exit(1)
}

func usage() {
	fmt.Fprintln(os.Stderr, "usage:", os.Args[0])
	flag.PrintDefaults()
	os.Exit(1)
}

func main() {
	output := flag.String("o", "", "write generated code to file")
	release := flag.Bool("r", false, "write output for release (server config format)")
	test := flag.Bool("t", false, "just exit with status code 0 (test if binary exists)")
	flag.Parse()
	if flag.NArg() != 0 {
		usage()
	}
	if *test {
		return
	}
	commit, date, err := git.GetHead("", os.Stderr)
	if err != nil {
		fatal(err)
	}
	outfp := os.Stdout
	if *output != "" {
		if !commitChanged(*output, commit) {
			// nothing to write
			return
		}
		outfp, err = os.Create(*output)
		if err != nil {
			fatal(err)
		}
	}
	printCode(outfp, *release, commit, date)
}
